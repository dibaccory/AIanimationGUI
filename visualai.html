<!-- Jonathon Rice, Richard DiBacco, Soliman Alnaizy -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Neural Network Builder</title>
		<link rel="stylesheet" type="text/css" href="index.css">
	</head>
	<body>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"></script>
	<script src="lib/main.js"></script>
	<script type= "module" src="lib/model.js"></script>
	<script src="lib/Layer.js"></script>
	<script src="lib/Network.js"></script>
	<script type= "module">
		// GLOBAL VARIABLES
		var container; 		                                // Will be used to add the .js script to the browser
		var camera, raycaster, renderer, scene;             // Three.js essentials
		var controls;                                       // For orbital controls
		var isPlaying = false, isDrawing = false;           // For the play/pause button
		var mouse = new THREE.Vector3();                    // For the raycaster
		var selectedObject = null, group;                   // For the raycaster
		var panDistance = 200;								// Determines how face the camera pans
		var oricolor = [];
		var q = 0, x = 0;

		// CONSTANTS
		var RADIUS = 300, THETA = 0;                        // Camera rotation and movement
		var HIGHLIGHT_COLOR = new THREE.Color ( 0xFF0000 ); // Object highlight for raycaster
		var PANSPEED = 1, ROTATIONSPEED = 1, DRAWLINESPEED = 1, LAYER_DELAY;
		var IMAGE_SIZE = 784;


		// Grabs model data from other js module
		import {data, model} from './lib/model.js';

		// The first function that loads
		window.onload = function() 
		{

			// wait for training to finish
			// setTimeout(function()
			// {
				init();
				animate();
				// console.log(model);
			// }, 17000);
		}

		// Draws a line that connects the point p1 to point p2
		function draw(p1, p2) 
		{
			var mat = new THREE.LineBasicMaterial({color:0x888888});
			var geo = new THREE.Geometry();
			geo.vertices.push( new THREE.Vertex(p1) );
			geo.vertices.push( new THREE.Vertex(p2) );
			var line = new THREE.Line(geo);
			scene.add(line);
			return line
		}
		
		function createLayer( mnistNetwork ) 
		{
			for (var layer; layer < mnistNetwork.length; layer++ ) {	
				v3loop( mnistNetwork[layer].volume, ( i, j, k ) => {
					scene.add( mnistNetwork[layer].nodes[k][j][i] );
				});
			}
		}

		// 1D array, channels, width, height
		// outputs js array in original shape
		function oneDToMany(layer, n, m , l)
		{
			var arr =  Array.prototype.slice.call(layer);
			var newArr = [];
			var newArr2 = [];
			var finalarr = [];
			while(arr.length) 
			{
				newArr.push(arr.splice(0,n));
			}
			while(newArr.length) 
			{
				newArr2.push(newArr.splice(0,m));
			}
			while(newArr2.length) 
			{
				finalarr.push(newArr2.splice(0,l));
			}

			return finalarr;
		}

		// layer rendering abstraction
		var ilayer = 1;
		function imgVis(layer, scene, group, num)
		{
			var R, B, G;
			var geometry = new THREE.BoxGeometry(10, 10, 10);

			for(let t = 0; t < layer[0][0][0].length; t++)
			{
				for(let i = -layer[0][0].length/2; i < layer[0][0].length/2; i++)
				{
					for(let j = -layer[0].length/2; j < layer[0].length/2; j++)
					{
							if(ilayer == 1)
							{
								R = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								B = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								G = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
							}
							else
							{
								if(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] <= .5)
								{
									R = 0;
									B = 1 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
									G = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								}
								else
								{
									B = 0;
									R = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] - 1;
									G = 2 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								}
							}

							var colors = new THREE.Color( R, G, B );
							var material = new THREE.MeshBasicMaterial( { color: colors } );
							var cube = new THREE.Mesh( geometry, material );
							cube.position.x += 12*i;
							cube.position.y += 12*(-j);
							if(ilayer == 1)
							{
								cube.position.z += t*-25 + (-100*num);
							}
							else
							{
								cube.position.z += t*-25 + (-200*num);
							}
							cube.original = colors;
							scene.add( cube );
							group.add( cube );
					}
				}
			}

			return {scene: scene, group: group};
		}

		var dense1 = 1;
		function denseVis(layer, scene, group, num)
		{
			var R, B, G;
			var geometry = new THREE.BoxGeometry(10, 10, 10);

			for(let j = -layer.length/2; j < layer.length/2; j++)
			{
				if(layer[j+layer.length/2] <= .5)
				{
					R = 0;
					B = 1 - 2*layer[j+layer.length/2];
					G = 2*layer[j+layer.length/2];
				}
				else
				{
					B = 0;
					R = 2*layer[j+layer.length/2] - 1;
					G = 2 - 2*layer[j+layer.length/2];
				}

				var colors = new THREE.Color( R, G, B );
				var material = new THREE.MeshBasicMaterial( { color: colors } );
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x += 12*j;
				if(dense1 == 1)
				{
					cube.position.z += (-200*num) - 50;
				}
				else
				{
					cube.position.z += (-200*(num-1)) - 150;
				}
				cube.original = colors;
				scene.add( cube );
				group.add( cube );
			}

			return {scene: scene, group: group};
		}
		
		// Initializes all the necessary variables for a basic THREE.js application
		async function init() 
		{
		
			container = document.createElement( 'div' );
			document.body.appendChild( container );
		
			// Renderer stuff
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			container.appendChild( renderer.domElement );
		
			// Setting the scene
			scene = new THREE.Scene();
		
			// Camera stuff
			var aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 3000 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
			scene.add( camera );
		
			// Light stuff
			var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 1.0 );
			scene.add( ambientLight );
		
			// A Raycaster can tell what object is the mouse hovering over
			raycaster = new THREE.Raycaster();
			group = new THREE.Group();
			scene.add( group );

			// Layer visualizations
			// input layer, select based off img size
			var input = data.datasetImages.slice(IMAGE_SIZE*5, IMAGE_SIZE*6);
			var img = oneDToMany(input, 1, 28, 28);
			var stuffz = imgVis(img, scene, group, 0);
			scene = stuffz.scene;
			group = stuffz.group;
			ilayer = 0;

			// loop through conv and pool layers
			var output = tf.tensor4d(img);
			for(let i = 0; i < 4; i++)
			{
				var output = model.getLayer('', i).apply(output);
				var fmap = oneDToMany(output.dataSync(), output.shape[3], output.shape[2], output.shape[1]);
				var stuffz = imgVis(fmap, scene, group, i+1);
				scene = stuffz.scene;
				group = stuffz.group;
				// console.log(fmap);
			}

			// flatten layer
			var output = model.getLayer('', 4).apply(output);
			// 1st dense layer
			var output = model.getLayer('', 5).apply(output);
			var stuffz = denseVis(output.dataSync(), scene, group, 5);
			scene = stuffz.scene;
			group = stuffz.group;
			dense1 = 0;
			// console.log(output.dataSync());

			// prediction layer
			var output = model.getLayer('', 6).apply(output);
			var stuffz = denseVis(output.dataSync(), scene, group, 6);
			scene = stuffz.scene;
			group = stuffz.group;
			// console.log(output.dataSync());

			for(let l = 0; l < IMAGE_SIZE; l++)
			{
				oricolor.push(group.children[l].material.color);
			}
			// console.log(oricolor);

			// var m = 0, y = 0, r = 0, x = 0;
			// // Kernel animation
			// setTimeout(function()
			// {
			// 	for(let q = 0; q < IMAGE_SIZE; q++)
			// 	{
			// 		setTimeout(function()
			// 		{
			// 			y = 0;
			// 			// range of z changing when it shouldn't?
			// 			for(let z = m-Math.floor(5/2); z < m+Math.floor(5/2)+1; z++)
			// 			{	
			// 				r = 0;
			// 				for(let s = q-Math.floor(5/2); s < q+Math.floor(5/2)+1; s++)
			// 				{	
			// 					if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
			// 					{
			// 						// oricolor.push(group.children[z*28+s].material.color);
			// 						group.children[z*28+s].material.color = new THREE.Color ( 1, 0, 0 );
			// 					}
			// 					// color center of kernel
			// 					if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE && r == 2 && y == 2)
			// 						group.children[z*28+s].material.color = new THREE.Color ( 0, 0, 1 );

			// 					r += 1;
			// 				}
			// 				y += 1;
			// 			}
			// 		}, q*50);

			// 		setTimeout(function()
			// 		{
			// 			setTimeout(function()
			// 			{	
			// 				console.log(oricolor);
			// 				for(let z = m-Math.floor(5/2); z < m+Math.floor(5/2)+1; z++)
			// 				{	
			// 					for(let s = q-Math.floor(5/2); s < q+Math.floor(5/2)+1; s++)
			// 					{	
			// 						if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
			// 							group.children[z*28+s].material.color = oricolor[z*28+s];
			// 					}
			// 				}
			// 			}, q*50);
			// 		}, 30);
			// 	}
			// }, 1000);


			// group.children[0].material.color = new THREE.Color ( 0, 0, 1 );
			// group.children[27].material.color = new THREE.Color ( 0, 0, 1 );
			// group.children[28].material.color = new THREE.Color ( 0, 0, 1 );
			// group.children[29].material.color = new THREE.Color ( 0, 0, 1 );
			// group.children[56].material.color = new THREE.Color ( 0, 0, 1 );
		
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.screenSpacePanning = false;
			controls.maxPolarAngle = Math.PI / 2;
		
			// Makes the animation adapt to the size of the window
			window.addEventListener( "resize", resize, false );
		
			// This is what highlights the cubes when the mouse is over an object
			window.addEventListener( "mousemove", highlightObject, false );
		}
		
		// The program adapts to the size of the browser window
		function resize() {
		
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		
		}
		
		// For the raycaster
		function highlightObject( event ) 
		{
		
			event.preventDefault();
		
			// Restore the cube back to it's original once the mouse is no longer over it
			if ( selectedObject ) 
			{
				selectedObject.material.color.set( selectedObject.original );
				selectedObject = null;
			}
		
			var intersects = getIntersects( event.layerX, event.layerY );
		
			// If the mouse is intersecting with an object, change it's color
			if ( intersects.length > 0 ) 
			{
				var res = intersects.filter( function ( res ) 
				{
					return res && res.object;
				} )[ 0 ];
				if ( res && res.object ) 
				{
					selectedObject = res.object;
					selectedObject.material.color.set( HIGHLIGHT_COLOR );
				}
			}
		}
		
		function getIntersects( x, y )
		{
		
			x =  ( x / window.innerWidth  ) * 2 - 1;
			y = -( y / window.innerHeight ) * 2 + 1;
			mouse.set( x, y, 0.5 );
			raycaster.setFromCamera( mouse, camera );
		
			return raycaster.intersectObject( group, true );
		}

		function convAnimate()
		{
			var y = 0, r = 0;

			if (q < IMAGE_SIZE)
			{
				setTimeout(function()
				{
					for(let z = -Math.floor(5/2); z < Math.floor(5/2)+1; z++)
					{	
						for(let s = q-Math.floor(5/2); s < q+Math.floor(5/2)+1; s++)
						{	
							if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
								group.children[z*28+s].material.color = oricolor[z*28+s];
						}
					}
					q += 1;
				}, 10);

				// setTimeout(function()
				// {
					y = 0;
					// range of z changing when it shouldn't?
					for(let z = -Math.floor(5/2); z < Math.floor(5/2)+1; z++)
					{	
						r = 0;
						for(let s = q-Math.floor(5/2); s < q+Math.floor(5/2)+1; s++)
						{	
							if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
							{
								// oricolor.push(group.children[z*28+s].material.color);
								group.children[z*28+s].material.color = new THREE.Color ( 1, 0, 0 );
							}
							// color center of kernel
							if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE && r == 2 && y == 2)
								group.children[z*28+s].material.color = new THREE.Color ( 0, 0, 1 );

							r += 1;
						}
						y += 1;
					}
				// }, 10);

			}
		}
		
		function animate() 
		{
		
			requestAnimationFrame( animate );
			render();
		
		}
		
		function render() 
		{

			// Outer if statement is to check whether it's in play or pause mode
			// Inner if statement is to rotate and pan camera around layers
			if ( isPlaying ) 
			{
				if ( THETA < 90 ) 
				{
					camera.position.x = RADIUS * Math.sin( THREE.Math.degToRad( THETA ) );
					camera.position.z = RADIUS * Math.cos( THREE.Math.degToRad( THETA ) );
					camera.lookAt( scene.position );
					THETA += ROTATIONSPEED;
				} 
				else if ( scene.position.z < panDistance ) 
				{
					camera.position.z -= PANSPEED;
					scene.position.z  += PANSPEED;
				}

				convAnimate();
			}

			if(!isPlaying && THETA == 0)
			{
				q = 0;
			}
		
			controls.update();
			renderer.render( scene, camera );
		}
		
		function play() 
		{
			isPlaying = true;
		}
		
		function pause() 
		{
			isPlaying = false;
		}
		
		function restart() 
		{
		
			isPlaying = false;
			THETA = 0;
			scene.position.set( 0, 0, 0 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
		
		}

		window.play = play;
		window.pause = pause;
		window.restart = restart;
	</script>
	<div id="info">
		Super Awesome Convolutional Neural Network Visualizer<br/>
		By: Jonathon Rice, Richard DiBacco, Soliman Alnaizy</br>
		<button onclick="play();">Play</button>
		<button onclick="pause();">Pause</button>
		<button onclick="restart();">Restart</button>

	</div>
	</body>
</html>