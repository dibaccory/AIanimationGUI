<!-- Jonathon Rice, Richard DiBacco, Soliman Alnaizy -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Neural Network Builder</title>
		<link rel="stylesheet" type="text/css" href="index.css">
	</head>
	<body>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"></script>
	<script src="lib/main.js"></script>
	<script type= "module" src="lib/model.js"></script>
	<script src="lib/Layer.js"></script>
	<script src="lib/Network.js"></script>
	<script type= "module">
		// GLOBAL VARIABLES
		var container; 		                                  // Will be used to add the .js script to the browser
		var camera, raycaster, renderer, scene;             // Three.js essentials
		var controls;                                       // For orbital controls
		var mouse = new THREE.Vector3();                    // For the raycaster
		var selectedObject = null, group;                   // For the raycaster
		var theta = 0;                                      // Camera rotating during animation
		var linesInScene = [];
		var cubeArray = [];
		var numbox = 0;
		var allColors = [];
		var kernelShape = model.layers[0].getWeights()[0].shape[0];
		var filterSize = model.layers[0].getWeights()[0].shape[3];
		var currentNode = 0, x = 0;
		var layerSize = [];
		var allColors = [];
		var lineGroup;
		var cubeToAnimate = 784;

		// Button stuff
		var isFinished = false, plzRestart = false, isPlaying = false;

		// CONSTANTS
		const RADIUS = 750;                                   // Camera rotation and movement
		const HIGHLIGHT_COLOR = new THREE.Color ( 0xFF0000 ); // Object highlight for raycaster
		const PANSPEED = 5, ROTATIONSPEED = 1;
		const PANDISTANCE = 0;	                            // Determines how far the camera pans
		const IMAGE_SIZE = 784;

		// Grabs model data from other js module
		import {data, model} from './lib/model.js';

		// The first function that loads
		window.onload = function() {
			setTimeout(function()
			{
				init();
				animate();
				// console.log(model);
			}, 15000);
		}

		// Draws a line that connects the point p1 to point p2
		function draw( p1, p2 ) {
			var mat = new THREE.LineBasicMaterial( { color: HIGHLIGHT_COLOR, linewidth: 2 } );
			var geo = new THREE.Geometry();
			geo.vertices.push( p1 );
			geo.vertices.push( p2 );
			var line = new THREE.Line( geo, mat );
			scene.add( line );
			// lineGroup.add(line);

			return line;
		}

        function drawLine( from, to ) {
            var mat = new THREE.LineBasicMaterial( { color: HIGHLIGHT_COLOR, linewidth: 2 } );
            var geo = new THREE.Geometry();
            geo.vertices.push( from );
            geo.vertices.push( to );
            var line = new THREE.Line( geo, mat );
            linesInScene.push(line);
            scene.add( line );
            // lineGroup.add(line);

            return line;
        }

		function findRGB( layer, dense )
		{
			var layerColors = [];
			var R, B, G;

			if(!dense)
			{
				for(let t = 0; t < layer[0][0][0].length; t++)
				{
					for(let i = -layer[0][0].length/2; i < layer[0][0].length/2; i++)
					{
						for(let j = -layer[0].length/2; j < layer[0].length/2; j++)
						{
							if(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] <= .5)
							{
								R = 0;
								B = 1 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								G = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
							}
							else
							{
								B = 0;
								R = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] - 1;
								G = 2 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
							}

								var color = new THREE.Color( R, G, B );
								allColors.push(color);
						}
					}
				}
			}

			if(dense)
			{
				for(let i = 0; i < layer.length; i++)
				{
					if(layer[i] <= .5)
					{
						R = 0;
						B = 1 - 2*layer[i];
						G = 2*layer[i];
					}
					else
					{
						B = 0;
						R = 2*layer[i];
						G = 2 - 2*layer[i];
					}

					var color = new THREE.Color( R, G, B );
					allColors.push(color);
				}
			}
		}

		// 1D array, channels, width, height
		// outputs js array in original shape
		function oneDToMany( layer, n, m , l ) {
			var arr =  Array.prototype.slice.call(layer);
			var newArr = [];
			var newArr2 = [];
			var finalarr = [];
			while(arr.length) 
			{
				newArr.push(arr.splice(0,n));
			}
			while(newArr.length) 
			{
				newArr2.push(newArr.splice(0,m));
			}
			while(newArr2.length) 
			{
				finalarr.push(newArr2.splice(0,l));
			}

			return finalarr;
		}

		// layer rendering abstraction
		var ilayer = 1;
		function imgVis(layer, scene, group, num)
		{
			var R, B, G;
			var geometry = new THREE.BoxGeometry( 10, 10, 10);

			for(let t = 0; t < layer[0][0][0].length; t++)
			{
				for(let i = -layer[0][0].length/2; i < layer[0][0].length/2; i++)
				{
					for(let j = -layer[0].length/2; j < layer[0].length/2; j++)
					{
							if(ilayer == 1)
							{
								R = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								B = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								G = layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
							}
							else
							{
								if(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] <= .5)
								{
									R = 0;
									B = 1 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
									G = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								}
								else
								{
									B = 0;
									R = 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t] - 1;
									G = 2 - 2*layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t];
								}
							}

							var colors = new THREE.Color( R, G, B );
							var material = new THREE.MeshPhongMaterial( { color: colors } );
							var cube = new THREE.Mesh( geometry, material );
							cube.position.x += 12*i;
							cube.position.y += 12*j;
							if(ilayer == 1)
							{
								cube.position.z += t*-25 + (-100*num);
							}
							else
							{
								cube.position.z += t*-25 + (-200*num);
							}
							cube.original = colors;

							cube.number = numbox++;
                        	cubeArray.push( cube);
                        	if(cube.number > 783)
                        	{
                            	getLinesForCube(cube);
                        	}

							scene.add( cube );
							group.add( cube );


					}
				}
			}

			return {scene: scene, group: group};
		}

		var dense1 = 1;
		function denseVis(layer, scene, group, num)
		{
			var R, B, G;
			var geometry = new THREE.BoxGeometry( 10, 10, 10);

			for(let j = -layer.length/2; j < layer.length/2; j++)
			{
				if(layer[j+layer.length/2] <= .5)
				{
					R = 0;
					B = 1 - 2*layer[j+layer.length/2];
					G = 2*layer[j+layer.length/2];
				}
				else
				{
					B = 0;
					R = 2*layer[j+layer.length/2] - 1;
					G = 2 - 2*layer[j+layer.length/2];
				}

				var colors = new THREE.Color( R, G, B );
				var material = new THREE.MeshPhongMaterial( { color: colors } );
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x += 12*j;
				if(dense1 == 1)
				{
					cube.position.z += (-200*num) - 50;
				}
				else
				{
					cube.position.z += (-200*(num-1)) - 150;
				}
				cube.original = colors;
				cube.number = numbox++;
				//console.log(cube.number);
                cubeArray.push( cube);
                getLinesForCube(cube);

				scene.add( cube );
				group.add( cube );

			}

			return {scene: scene, group: group};
		}
		
		// Initializes all the necessary variables for a basic THREE.js application
		async function init() {
		
			container = document.createElement( 'div' );
			document.body.appendChild( container );
		
			// Renderer stuff
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			container.appendChild( renderer.domElement );


		
			// Setting the scene
			scene = new THREE.Scene();
		
			// Camera stuff
			var aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 45, aspect, 1, 5000 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
			scene.add( camera );

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
		
			// Light stuff
			var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.5 );
			scene.add( ambientLight );
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1.0 );
			dirLight.position.set( 1, 0, 1 ).normalize();
			scene.add( dirLight );
		
			// A Raycaster can tell what object is the mouse hovering over
			raycaster = new THREE.Raycaster();
			group = new THREE.Group();
			lineGroup = new THREE.Group();
			scene.add( group );
			scene.add( lineGroup );
			
			// Layer visualizations
			// input layer
			var input = data.datasetImages.slice(784, 1568);
			var img = oneDToMany(input, 1, 28, 28);
			var stuffz = imgVis(img, scene, group, 0);
			scene = stuffz.scene;
			group = stuffz.group;
			ilayer = 0;

			// loop through conv and pool layers
			var output = tf.tensor4d(img);
			for(let i = 0; i < 4; i++)
			{
				var output = model.getLayer('', i).apply(output);
				var fmap = oneDToMany(output.dataSync(), output.shape[3], output.shape[2], output.shape[1]);
				var stuffz = imgVis(fmap, scene, group, i+1);
				scene = stuffz.scene;
				group = stuffz.group;
				console.log(fmap);
			}

			// flatten layer
			var output = model.getLayer('', 4).apply(output);

			// 1st dense layer
			var output = model.getLayer('', 5).apply(output);
			var stuffz = denseVis(output.dataSync(), scene, group, 5);
			scene = stuffz.scene;
			group = stuffz.group;
			dense1 = 0;
			console.log(output.dataSync());

			// prediction layer
			var output = model.getLayer('', 6).apply(output);
			var stuffz = denseVis(output.dataSync(), scene, group, 6);
			scene = stuffz.scene;
			group = stuffz.group;
			console.log(output.dataSync());
		


			var loader = new THREE.FontLoader();

			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "First Convolution", {

        font: font,

        size: 25,
        height: 10,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 120, 150, -150 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );

			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "Max Pool", {

        font: font,

        size: 25,
        height: 10,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 50, 75, -400 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );
		
			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "2nd Convolution", {

        font: font,

        size: 15,
        height: 5,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 40, 50, -610 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );

			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "Max Pool", {

        font: font,

        size: 15,
        height: 5,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 20, 30, -840 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );

			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "Dense", {

        font: font,

        size: 10,
        height: 2,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 10, 30, -1030 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );

			loader.load( 'lib/helvetiker_regular.typeface.json', function ( font ) {

    		var textGeo = new THREE.TextGeometry( "Output", {

        font: font,

        size: 10,
        height: 2,
        curveSegments: 12,

        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true

    		} );

		    var textMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

		    var mesh = new THREE.Mesh( textGeo, textMaterial );
		    mesh.position.set( 10, 30, -1125 );
		    mesh.rotateY(Math.PI / 2)
		    scene.add( mesh );
			} );

			// Makes the animation adapt to the size of the window
			window.addEventListener( "resize", resize, false );
		
			// This is what highlights the cubes when the mouse is over an object
			window.addEventListener( "mousemove", highlightObject, false );
		}


		
		// The program adapts to the size of the browser window
		function resize() {
		
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		
		}
		//
		// function getAllLines()
		// {
		//     lines[0] = [];
		//     lines[1] = [];
		//     lines[2] = [];
		//     lines[3] = [];
		//     lines[4] = [];
		//     lines[5] = [];
		//
		//     for(let i = 784; i < cubeArray.length; i++)
		// 	{
		// 	    //get layer cube is in
		// 		let layer = whichLayer(cubeArray[i]);
		//
        //         lines[layer][]
		// 		//get array of lines for this cube
		// 		let linesForCube = getLinesForCube(layer, cubeArray[i]);
		// 		lines[layer][i].push(linesForCube);
		//
		// 	}
		// }

		function getLinesForCube(cube)
		{
		    let index = whichLayer(cube.number);
		    console.log(cube.number);

			cube.lines = [];
			let i,j,k;
		    switch (index)
			{
				case 0:
                    for (i = -2; i <= 2; i++)
                    {
                        for (j = -2; j <= 2; j++)
                        {
                            var col = Math.floor((( cube.number - 784 ) % 576 ) / 24);
                            var row = (( cube.number - 784 ) % 576 ) % 24;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                to: cubeArray[ col * 28 + 58 + row + i + 28*j].position } );
                        }
                    }
                    break;

				case 1:
                    for (i = 0; i <= 1; i++)
                    {
                        for (j = 0; j <= 1; j++)
                        {
                            var col = Math.floor((( cube.number - 4240 ) % 144 ) / 12);
                            var row = (( cube.number - 4240 ) % 144 ) % 12;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                to: cubeArray[ 3664 + 24 * col*2 + i + 24 * j + row*2].position } );
                        }
                    }
                    break;

				case 2:
                    for (k = 0; k < 6; k++)
                    {
                        for (i = -2; i <= 2; i++)
                        {
                            for (j = -2; j <= 2; j++)
                            {
                                var col = Math.floor((( cube.number - 5104 ) % 64 ) / 8);
                                var row = (( cube.number - 5104 ) % 64 ) % 8;

                                cube.lines.push( { from: cubeArray[ cube.number ].position,
                                    to: cubeArray[ col * 12 + (4266 + 144*k) + row + i + 12*j].position } );
                            }
                        }
                    }
                    break;

				case 3:
                    for (i = 0; i <= 1; i++)
                    {
                        for (j = 0; j <= 1; j++)
                        {
                            var col = Math.floor((( cube.number - 5616 ) % 16 ) / 4);
                            var row = (( cube.number - 5616 ) % 16 ) % 4;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                 to: cubeArray[ 5552 + 8 * col*2 + i + 8 * j + row*2].position } );
                        }
                    }
                    break;

				case 4:
                    for (j = 5616; j <= 5743; j++)
                    {
                        cube.lines.push( {from: cubeArray[ cube.number ].position,
                            to: cubeArray[ j ].position } );
                    }
                    break;

				case 5:
                    for (j = 5744; j <= 5793; j++)
                    {
                        cube.lines.push( {from: cubeArray[ cube.number ].position,
                            to: cubeArray[ j ].position } );
                    }
                    break;

			}
		    //lines[6][ALL_NODES_IN_THIS][paths for each nodes]

		}

		function whichLayer(i)
		{
		    let inLayer = (i, a, b) => {return i >= a && i <= b};
		    let index = -1;
		    switch (true)
			{
				case inLayer(i, 784, 4239):
				    index = 0;
				    break;

				case inLayer(i, 4240, 5103):
				    index = 1;
				    break;

				case inLayer(i, 5104, 5615):
				    index = 2;
				    break;

				case inLayer(i, 5616, 5743):
				    index = 3;
				    break;

				case inLayer(i, 5744, 5793):
				    index = 4;
				    break;

				case inLayer(i, 5794, 5803):
				    index = 5;
				    break;
			}
		    return index;
		}
		
		// For the raycaster
		function highlightObject( event ) {
		
			event.preventDefault();
		
			// Restore the cube back to it's original once the mouse is no longer over it
			if ( selectedObject ) {
				selectedObject.material.color.set( selectedObject.original );
				selectedObject = null;


				for (var i = 0; i < linesInScene.length; i++)
					scene.remove( linesInScene[i] );
				linesInScene = [];
			}
		
			var intersects = getIntersects( event.layerX, event.layerY );
		
			// If the mouse is intersecting with an object, change it's color
			if ( intersects.length > 0 ) {
				var res = intersects.filter( function ( res ) {
					return res && res.object;
				} )[ 0 ];
                if ( res && res.object ) {
                    selectedObject = res.object;
                    selectedObject.material.color.set(HIGHLIGHT_COLOR);


                    if(selectedObject.number > 783){
                        //console.log(selectedObject.number);
                    	for(let line = 0; line < selectedObject.lines.length; line++) {
                    	    drawLine(selectedObject.lines[line].from, selectedObject.lines[line].to);
                    	}
                    }
                }
				/*

					// First Conv
					if (selectedObject.number >= 784 && selectedObject.number <= 4239)
					{
						for (var i = -2; i <= 2; i++)
						{
							for (var j = -2; j <= 2; j++)
							{
								var col = Math.floor((( selectedObject.number - 784 ) % 576 ) / 24);
								var row = (( selectedObject.number - 784 ) % 576 ) % 24;

								lines.push( draw( cubeArray[ selectedObject.number ].position,
								                  cubeArray[ col * 28 + 58 + row + i + 28*j].position ) );
							}
						}
					}
					// First max pooling
					else if (selectedObject.number >= 4240 && selectedObject.number <= 5103)
					{
						for (var i = 0; i <= 1; i++)
						{
							for (var j = 0; j <= 1; j++)
							{
								var col = Math.floor((( selectedObject.number - 4240 ) % 144 ) / 12);
								var row = (( selectedObject.number - 4240 ) % 144 ) % 12;

								lines.push( draw( cubeArray[ selectedObject.number ].position,
								                  cubeArray[ 3664 + 24 * col*2 + i + 24 * j + row*2].position ) );
							}
						}
					}
					// Second conv.
					else if (selectedObject.number >= 5104 && selectedObject.number <= 5615)
					{
						for (var k = 0; k < 6; k++)
						{
							for (var i = -2; i <= 2; i++)
							{
								for (var j = -2; j <= 2; j++)
								{
									var col = Math.floor((( selectedObject.number - 5104 ) % 64 ) / 8);
									var row = (( selectedObject.number - 5104 ) % 64 ) % 8;

									lines.push( draw( cubeArray[ selectedObject.number ].position,
									                  cubeArray[ col * 12 + (4266 + 144*k) + row + i + 12*j].position ) );
								}
							}
						}
					}
					// second max pooling
					else if (selectedObject.number >= 5616 && selectedObject.number <= 5743)
					{
						for (var i = 0; i <= 1; i++)
						{
							for (var j = 0; j <= 1; j++)
							{
								var col = Math.floor((( selectedObject.number - 5616 ) % 16 ) / 4);
								var row = (( selectedObject.number - 5616 ) % 16 ) % 4;

								lines.push( draw( cubeArray[ selectedObject.number ].position,
								                  cubeArray[ 5552 + 8 * col*2 + i + 8 * j + row*2].position ) );
							}
						}
					}
					// Dense layer
					else if (selectedObject.number >= 5744 && selectedObject.number <= 5793)
					{
						for (var j = 5616; j <= 5743; j++)
						{
							lines.push( draw( cubeArray[ selectedObject.number ].position,
							                  cubeArray[ j ].position ) );
						}
					}
					// Output
					else if (selectedObject.number >= 5794 && selectedObject.number <= 5803)
					{
						for (var j = 5744; j <= 5793; j++)
						{
							lines.push( draw( cubeArray[ selectedObject.number ].position,
							                  cubeArray[ j ].position ) );
						}
					}
				}*/
			}
		}
		
		function getIntersects( x, y ) {
		
			x =  ( x / window.innerWidth  ) * 2 - 1;
			y = -( y / window.innerHeight ) * 2 + 1;
			mouse.set( x, y, 0.5 );
			raycaster.setFromCamera( mouse, camera );
		
			return raycaster.intersectObject( group, true );
		}
		
		function animate() {
		
			requestAnimationFrame( animate );
			render();
		
		}



		function layerVolume(l)
		{
		    let d;
            switch (l)
            {
                case 0:
                    d = {x: 24, y: 24, z: 6};
                    break;

                case 1:
                    d = {x: 12, y: 12, z: 6};
                    break;

                case 2:
                    d = {x: 8, y: 8, z: 8};
                    break;

                case 3:
                    d = {x: 4, y: 4, z: 8};
                    break;
            }
            return d;
		}

		function animateLines(i)
		{
            let volume = [784, 4240, 5104, 5616, 5744, 5794];
		    let layer = whichLayer(i);
		    let v = layerVolume(layer);

			for(let line = 0; line < cubeArray[i].lines.length; line++)
			{
			    if(v && layer !=2)
				{
                	for(let depth = 0; depth < v.z; depth++)
                    	drawLine(cubeArray[i + depth * (v.x * v.y - 1)].lines[line].from, cubeArray[i + depth * (v.x * v.y - 1)].lines[line].to);
                }
			    else
                    drawLine(cubeArray[i].lines[line].from, cubeArray[i].lines[line].to);

            }
            if(layer < 4) {
                if((i - volume[layer] < v.x * v.y))
				{
				    cubeToAnimate++;
				}
                else
                	cubeToAnimate = volume[layer + 1];
            }
            else
                cubeToAnimate++;

		}

		function removeLines()
		{
			for (let k = 0; k < linesInScene.length; k++)
				scene.remove( linesInScene[k] );
			linesInScene = [];
		}

		function convAnimate()
		{
			var y = 0, r = 0;
			var line;

			if (currentNode < IMAGE_SIZE)
			{	

				// kernel highlight of current computation
				y = 0;
				for(let z = -Math.floor(kernelShape/2); z < Math.floor(kernelShape/2)+1; z++)
				{	
					r = 0;
					for(let s = currentNode-Math.floor(kernelShape/2); s < currentNode+Math.floor(kernelShape/2)+1; s++)
					{	
						if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
						{
							group.children[z*28+s].material.color = new THREE.Color ( 1, 0, 0 );

							// line = draw(group.children[z*28+s].position, group.children[currentNode+IMAGE_SIZE].position);
						}

						// color center of kernel
						if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE && r == 2 && y == 2)
						{
							group.children[z*28+s].material.color = new THREE.Color ( 0, 0, 1 );

							line = draw(group.children[z*28+s].position, group.children[z*28+s+IMAGE_SIZE].position);

							for(let v = 1; v <= filterSize; v++)
								group.children[z*28+s+IMAGE_SIZE*v].material.color = new THREE.Color ( 1, 0, 0 );
						}


						r += 1;
					}
					y += 1;
				}

				// Recolors original color after highlighting with kernel and ops
				setTimeout(function()
				{	
					y = 0;
					for(let z = -Math.floor(kernelShape/2); z < Math.floor(kernelShape/2)+1; z++)
					{	
						r = 0;
						for(let s = currentNode-Math.floor(kernelShape/2); s < currentNode+Math.floor(kernelShape/2)+1; s++)
						{	
							if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE)
								group.children[z*28+s].material.color = allColors[z*28+s];

							if(s+z*28 >= 0 && s >= 0 && s+z*28 < IMAGE_SIZE && r == 2 && y == 2)
							{
								for(let v = 1; v <= filterSize; v++)
									group.children[z*28+s+IMAGE_SIZE*v].material.color = allColors[z*28+s+IMAGE_SIZE*v];
							}

							scene.remove(lineGroup.children[0]);
							lineGroup.remove(lineGroup.children[0]);
							r += 1;
						}
						y += 1;
					}
					currentNode += 1;
				}, 10);
			}
		}
		
		function render() {

			// Outer if statement is to check whether it's in play or pause mode
			// Inner if statement is to rotate and pan camera around layers
			if ( isPlaying ) {
				if ( theta < 90 ) {
		
					camera.position.x = RADIUS * Math.sin( THREE.Math.degToRad( theta ) );
					camera.position.z = RADIUS * Math.cos( THREE.Math.degToRad( theta ) );
					theta += ROTATIONSPEED;
				}
				// else if ( camera.position.z < PANDISTANCE ) {
		
				//  	camera.position.z -= PANSPEED;
				//  	scene.position.z  += PANSPEED;

				// }
                removeLines();
				// convAnimate();
				if(cubeToAnimate < cubeArray.length) {
                    animateLines(cubeToAnimate);

                }
			}

			// restart
			if( plzRestart )
			{
				currentNode = 0;
				for(let i = IMAGE_SIZE; i < group.children.length; i++)
					group.children[i].material.color = new THREE.Color ( 0.3, 0.3, 0.3 );
			}

			if( isFinished )
			{
				for (let i = 0; i < allColors.length; i++)
					group.children[i].material.color = allColors[i];
			}
		
			controls.update();
			renderer.render( scene, camera );
		}
		
		function play() {
			isPlaying = true;
		}
		
		function pause() {
			isPlaying = false;
		}
		
		function restart() {
            cubeToAnimate = 784;
			isPlaying = false;
			theta = 0;
			scene.position.set( 0, 0, 0 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
		
		}

		function finish() 
		{
			isFinished = true;
			plzRestart = false;
		}

		window.play = play;
		window.pause = pause;
		window.restart = restart;
		window.finish = finish;

	</script>
	<div id="info">
		Super Awesome Convolutional Neural Network Visualizer<br/>
		By: Jonathon Rice, Richard DiBacco, Soliman Alnaizy</br>
		<button onclick="play();">Play</button>
		<button onclick="pause();">Pause</button>
		<button onclick="restart();">Restart</button>
		<button onclick="finish();">Finish</button>

	</div>
	</body>
</html>