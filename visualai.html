<!-- Jonathon Rice, Richard DiBacco, Soliman Alnaizy -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Neural Network Builder</title>
		<link rel="stylesheet" type="text/css" href="index.css">
	</head>
	<body>
	<script src="https://threejs.org/build/three.js"></script>
	<script src='https://threejs.org/examples/js/libs/dat.gui.min.js'></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"></script>
	<script src="lib/main.js"></script>
	<script type= "module" src="lib/model.js"></script>
	<script src="lib/Layer.js"></script>
	<script src="lib/Network.js"></script>
	<script type="text/javascript" src="lib/colormap.json"></script>
	<script src="lib/textRender.js"></script>
	<script type= "module">
		// GLOBAL VARIABLES
		var container;								// Will be used to add the .js script to the browser
		var camera, raycaster, renderer, scene;     // Three.js essentials
		var controls;                               // For orbital controls
		var mouse = new THREE.Vector3();            // For the raycaster
		var selectedObject = null, group;           // For the raycaster
		var theta = 0;                              // Camera rotating during animation
		var linesInScene = [];						// Holds currently rendered lines
		var cubeArray = [];							// Holds currently rendered cubes
		var numbox = 0;								// count total cubes
		var layerSize = [];							// independent size of each layer
		var layerSum = [];							// total nodes up to current layer
		var allColors = [];							// holds all current colors
		var cubeToAnimate = 784;					// Where input ends and network begins
		var waitOver = false;						// when 1st colors are ready
		var IMG;									// holds current input img
		var imgNum = 5;								// image number from dataset
		var useMap = 3;								// color space being used
		var gui;									// dat gui
		var HIGHLIGHT_COLOR = new THREE.Color ( 0xFF0000 ); // Object highlight for raycaster

		// Button stuff
		var isFinished = false, plzRestart = false, isPlaying = false;

		// CONSTANTS
		const RADIUS = 750;                                   // Camera rotation and movement
		const PANSPEED = 5, ROTATIONSPEED = 1;
		const PANDISTANCE = 0;	                            // Determines how far the camera pans
		const IMAGE_SIZE = 784;

		// Grabs model data from other js module
		import {data, model} from './lib/model.js';


		let colorSelect = {
      		map : "jet"
        };

        // drop down to select color space
		let colorChange = function() {
            switch (colorSelect.map) {
	            case "viridis": useMap = 1; break;
	            case "plasma": useMap = 2; break;
	            case "jet": useMap = 3; break;
            }
            let RGB = colorMap(1, useMap);
            console.log(RGB);
            HIGHLIGHT_COLOR = new THREE.Color( RGB[0], RGB[1], RGB[2] );
            imgNum--;
            next();
        }

		// The first function that loads
		window.onload = function() {
			init();
			animate();
		}

		// normalizes output of an entire layer
		function normalize(array) {
		    let maxi = Math.max.apply(Math, array);
		    let mini = Math.min.apply(Math, array);
		    let ratio = maxi - mini;
		    let i, j, k;

			for (i = 0; i < array.length; i++) {
				array[i] += Math.abs(mini);
			    array[i] /= ratio;
			}

			return array;
		}

		// Colormap functions, if no color space passed then gray scale used
		function colorMap(value, map = 0) {
			let RGB = [];

			if (value > 1)
			{
				value = 1;
			}

			// gray scale
			if (map == 0) 
			{
				RGB.push(value);
				RGB.push(value);
				RGB.push(value);
			}
			if (map == 1) 
			{
				RGB.push(viridis[Math.round(255*value)][0]);
				RGB.push(viridis[Math.round(255*value)][1]);
				RGB.push(viridis[Math.round(255*value)][2]);
			}
			if (map == 2)
			{
				RGB.push(plasma[Math.round(255*value)][0]);
				RGB.push(plasma[Math.round(255*value)][1]);
				RGB.push(plasma[Math.round(255*value)][2]);
			}
			// jet, blue to green to red heatmap
			if (map == 3)
			{
				if(value <= .5)
				{
					RGB.push(0);
					RGB.push(2*value);
					RGB.push(1 - 2*value);
				}
				else
				{
					RGB.push(2*value - 1);
					RGB.push(2 - 2*value);
					RGB.push(0);
				}
			}

			return RGB;
		}

		// Draws a line that connects the point p1 to point p2
		function draw( p1, p2 ) {
			let mat = new THREE.LineBasicMaterial( { color: HIGHLIGHT_COLOR, linewidth: 2 } );
	
			let geo = new THREE.Geometry();
			geo.vertices.push( p1 );
			geo.vertices.push( p2 );
			let line = new THREE.Line( geo, mat );
			scene.add( line );

			return line;
		}

        function drawLine( from, to, color = HIGHLIGHT_COLOR) {
            let mat = new THREE.LineBasicMaterial( { color: color, linewidth: 2 } );
            let geo = new THREE.Geometry();
            geo.vertices.push( from );
            geo.vertices.push( to );
            let line = new THREE.Line( geo, mat );
            linesInScene.push(line);
            scene.add( line );

            return line;
        }

        // output to color
		function findRGB( layer, dense, num )
		{
			let RGB = [], RGB2 = [];
			let weights;
			// console.log(layer);
			if (!ilayer && !model.getLayer('', num).name.includes("pool"))
			{
				weights = model.layers[num].getWeights()[0].dataSync();
				weights = normalize(weights.slice(0));
			}

			if(!dense)
			{
				for(let v = 0; v < layer[0][0][0].length; v++)
				{
					for(let i = -layer[0][0].length/2; i < layer[0][0].length/2; i++)
					{
						for(let j = -layer[0].length/2; j < layer[0].length/2; j++)
						{
							if(ilayer)
							{
								RGB = colorMap(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][v]);
							}
							else
							{
								RGB = colorMap(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][v], useMap);
							}

							let color = new THREE.Color( RGB[0], RGB[1], RGB[2] );
							allColors.push(color);

							if (!ilayer && !model.getLayer('', num).name.includes("pool"))
							{
								allColors[allColors.length-1].lineColors = [];
								let vol = model.layers[num].getWeights()[0].shape;
								for (let z = 0; z < vol[2]; z ++)
									for (let n = 0; n < vol[1]; n++)
										for (let k = 0; k < vol[0]; k++)
										{
											RGB2 = colorMap(weights[k+vol[0]*n+vol[0]*vol[1]*z+vol[0]*vol[1]*vol[2]*v], useMap);
											color = new THREE.Color( RGB2[0], RGB2[1], RGB2[2] );
											allColors[allColors.length-1].lineColors.push(color);
										}
							}
						}
					}
				}
			}

			if(dense)
			{
				for(let i = 0; i < layer.length; i++)
				{
					RGB = colorMap(layer[i], useMap);

					let color = new THREE.Color( RGB[0], RGB[1], RGB[2] );
					allColors.push(color);

					if (!ilayer && !model.getLayer('', num).name.includes("pool"))
					{
						allColors[allColors.length-1].lineColors = [];
						let vol = model.layers[num].getWeights()[0].shape;
						for (let k = 0; k < vol[0]; k++)
						{
							RGB2 = colorMap(weights[k+vol[0]*i], useMap);
							color = new THREE.Color( RGB2[0], RGB2[1], RGB2[2] );
							allColors[allColors.length-1].lineColors.push(color);
						}
					}
				}

			}

		}

		// 1D array, channels, width, height
		// outputs js array in original shape
		function oneDToMany( layer, n, m , l ) {
			let arr =  Array.prototype.slice.call(layer);
			let newArr = [];
			let newArr2 = [];
			let finalarr = [];
			while(arr.length) 
			{
				newArr.push(arr.splice(0,n));
			}
			while(newArr.length) 
			{
				newArr2.push(newArr.splice(0,m));
			}
			while(newArr2.length) 
			{
				finalarr.push(newArr2.splice(0,l));
			}

			return finalarr;
		}

		// layer rendering abstraction for imgs and conv layers
		var ilayer = true;
		function imgVis(layer, scene, group, num)
		{
			let RGB = [];
			let geometry = new THREE.BoxGeometry(10, 10, 10);

			for(let t = 0; t < layer[0][0][0].length; t++)
			{
				for(let i = -layer[0][0].length/2; i < layer[0][0].length/2; i++)
				{
					for(let j = -layer[0].length/2; j < layer[0].length/2; j++)
					{
							if(ilayer)
							{
								RGB = colorMap(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t]);
							}
							else
							{
								RGB = colorMap(layer[0][j+layer[0].length/2][i+layer[0][0].length/2][t], useMap);
							}

							let colors = new THREE.Color( RGB[0], RGB[1], RGB[2] );
							let material = new THREE.MeshPhongMaterial( { color: colors } );
							let cube = new THREE.Mesh( geometry, material );
							cube.position.x += 12*i;
							cube.position.y += 12*(-j);
							if(ilayer)
							{
								cube.position.z += t*-25 + (-100*num);
							}
							else
							{
								cube.position.z += t*-25 + (-200*num);
							}
							cube.original = colors;

							cube.number = numbox++;
                        	cubeArray.push( cube );
                        	if(cube.number > 783)
                        	{
                            	getLinesForCube(cube);
                        	}

							scene.add( cube );
							group.add( cube );


					}
				}
			}

			return {scene: scene, group: group};
		}

		// Render fully connected layers
		var dense1 = true;
		function denseVis(layer, scene, group, num)
		{
			let RGB = [];
			let geometry = new THREE.BoxGeometry(10, 10, 10);

			for(let j = -layer.length/2; j < layer.length/2; j++)
			{
				RGB = colorMap(layer[j+layer.length/2], useMap);

				let colors = new THREE.Color( RGB[0], RGB[1], RGB[2] );
				let material = new THREE.MeshPhongMaterial( { color: colors } );
				let cube = new THREE.Mesh( geometry, material );
				cube.position.x += 12*j;
				if(dense1)
				{
					cube.position.z += (-200*num) - 50;
				}
				else
				{
					cube.position.z += (-200*(num-1)) - 150;
				}
				cube.original = colors;
				cube.number = numbox++;
				//console.log(cube.number);
                cubeArray.push( cube );
                getLinesForCube( cube );

				scene.add( cube );
				group.add( cube );

			}

			return {scene: scene, group: group};
		}

		// Computes new outputs for network and converts to color
		function colorCoat()
		{
			allColors = [];

			// input layer
			ilayer = true;
			findRGB(IMG, false, -1);
			ilayer = false;

			let netout = tf.tensor4d(IMG);

			for (let i = 0; i < model.layers.length; i++)
			{	
				let currOut, tensorOut;

				netout = model.getLayer('', i).apply(netout);

				if(i != 4)
				{

					// if not output layer, normalize
					if (model.layers[i].outboundNodes.length != 0)
						currOut = normalize(netout.dataSync().slice(0));
					else
						currOut = netout.dataSync();

					if(i < layerSize.length - 2)
					{
						tensorOut = oneDToMany(currOut, netout.shape[3], netout.shape[2], netout.shape[1]);
						findRGB(tensorOut, false, i);
					}
					else
						findRGB(currOut, true, i);
				}
				currOut = null;
				tensorOut = null;
			}
			netout = null;
		}
		
		// Initializes all the necessary variables for a basic THREE.js application
		async function init() 
		{
		
			container = document.createElement( 'div' );
			document.body.appendChild( container );
		
			// Renderer stuff
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			container.appendChild( renderer.domElement );

			// Setting the scene
			scene = new THREE.Scene();
		
			// Camera stuff
			var aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 45, aspect, 1, 5000 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
			scene.add( camera );

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
		
			// Light stuff
			var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.5 );
			scene.add( ambientLight );
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1.0 );
			dirLight.position.set( 1, 0, 1 ).normalize();
			scene.add( dirLight );
		
			// A Raycaster can tell what object is the mouse hovering over
			raycaster = new THREE.Raycaster();
			group = new THREE.Group();
			scene.add( group );

			//////////////////////
			// calculates size of each layer, turn into a function
			let ntotal = IMAGE_SIZE;
			layerSize.push(IMAGE_SIZE);
			layerSum.push(ntotal);
			for (let i = 0; i < model.layers.length; i++)
			{	
				// dont include flatten layers
				if (!model.getLayer('', i).name.includes("flatten"))
				{	
					let outputShape = model.layers[i].inboundNodes[0].outputShapes[0];

					let totalSize = 1;
					for (let j = 1; j < outputShape.length; j++)
					{
						totalSize *= outputShape[j];
					}
					layerSize.push(totalSize);
					ntotal += totalSize
					layerSum.push(ntotal);
				}
			}
			////////////////////
			
			// Layer visualizations
			// input layer
			var input = data.datasetImages.slice(IMAGE_SIZE*5, IMAGE_SIZE*6);
			IMG = oneDToMany(input, 1, 28, 28);
			var stuffz = imgVis(IMG, scene, group, 0);

			scene = stuffz.scene;
			group = stuffz.group;
			ilayer = false;

			// loop through all layers, abstraction
			var stuffz, outputArray;
			var output = tf.tensor4d(IMG);
			for(let i = 0; i < model.layers.length; i++)
			{
				// layer computation
				output = model.getLayer('', i).apply(output);

				// Visualize all layers besides flatten
				if (!model.getLayer('', i).name.includes("flatten"))
				{	
					// normalize layer data for color space
					outputArray = normalize(output.dataSync().slice(0));

					// conv or pool layers
					if (!model.getLayer('', i).name.includes("dense"))
					{
						var fmap = oneDToMany(outputArray, output.shape[3], output.shape[2], output.shape[1]);
						stuffz = imgVis(fmap, scene, group, i+1);
					}
					// dense layers
					else
					{	
						if (i != model.layers.length - 1)
							stuffz = denseVis(outputArray, scene, group, i);
						// output layer, softmax so no normalization
						else
						{
							dense1 = false;
							stuffz = denseVis(output.dataSync(), scene, group, i);
						}
					}
				
					scene = stuffz.scene;
					group = stuffz.group;
				}
			}

			console.log(layerSize);
			console.log(layerSum);

			colorCoat();
			waitOver = true;

			// Add graphical text to scene
			scene = renderText(scene);

			// Makes the animation adapt to the size of the window
			window.addEventListener( "resize", resize, false );
		
			// This is what highlights the cubes when the mouse is over an object
			window.addEventListener( "mousemove", highlightObject, false );

			gui = new dat.GUI();
	        gui.add(colorSelect, "map", 
	          ["viridis","plasma","jet"] )
	          .name( "Color Map" )
	          .onChange( colorChange );
    	
    		// controls.addEventListener( 'change', next );
		}


		
		// The program adapts to the size of the browser window
		function resize() {
		
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		
		}
		

		function getLinesForCube(cube)
		{
		    let index = whichLayer(cube.number);
		    // console.log(cube.number);

			cube.lines = [];
			let i,j,k;
		    switch (index)
			{
				case 0:
                    for (i = -2; i <= 2; i++)
                    {
                        for (j = -2; j <= 2; j++)
                        {
                            var col = Math.floor((( cube.number - layerSum[0] ) % 576 ) / 24);
                            var row = (( cube.number - layerSum[0] ) % 576 ) % 24;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                to: cubeArray[ col * 28 + 58 + row + i + 28*j].position } );
                        }
                    }
                    break;

				case 1:
                    for (i = 0; i <= 1; i++)
                    {
                        for (j = 0; j <= 1; j++)
                        {
                            var col = Math.floor((( cube.number - layerSum[1] ) % 144 ) / 12);
                            var row = (( cube.number - layerSum[1] ) % 144 ) % 12;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                to: cubeArray[ 3664 + 24 * col*2 + i + 24 * j + row*2].position } );
                        }
                    }
                    break;

				case 2:
                    for (k = 0; k < 6; k++)
                    {
                        for (i = -2; i <= 2; i++)
                        {
                            for (j = -2; j <= 2; j++)
                            {
                                var col = Math.floor((( cube.number - layerSum[2] ) % 64 ) / 8);
                                var row = (( cube.number - layerSum[2] ) % 64 ) % 8;

                                cube.lines.push( { from: cubeArray[ cube.number ].position,
                                    to: cubeArray[ col * 12 + (4266 + 144*k) + row + i + 12*j].position } );
                            }
                        }
                    }
                    break;

				case 3:
                    for (i = 0; i <= 1; i++)
                    {
                        for (j = 0; j <= 1; j++)
                        {
                            var col = Math.floor((( cube.number - layerSum[3] ) % 16 ) / 4);
                            var row = (( cube.number - layerSum[3] ) % 16 ) % 4;

                            cube.lines.push( {from: cubeArray[ cube.number ].position,
                                 to: cubeArray[ 5552 + 8 * col*2 + i + 8 * j + row*2].position } );
                        }
                    }
                    break;

				case 4:
                    for (j = layerSum[3]; j < layerSum[4]; j++)
                    {
                        cube.lines.push( {from: cubeArray[ cube.number ].position,
                            to: cubeArray[ j ].position } );
                    }
                    break;

				case 5:
                    for (j = layerSum[4]; j < layerSum[5]; j++)
                    {
                        cube.lines.push( {from: cubeArray[ cube.number ].position,
                            to: cubeArray[ j ].position } );
                    }
                    break;

			}
		    //lines[6][ALL_NODES_IN_THIS][paths for each nodes]

		}

		function whichLayer(num)
		{
		    let index = -1;

		    for (let i = 0; i < layerSum.length-1; i++)
		    {	
		    	if(num >= layerSum[i] && num < layerSum[i+1])
		    	{
		    		index = i;
		    		break;
		    	}
		    }

		    return index;
		}
		
		// For the raycaster
		function highlightObject( event ) 
		{
		
			event.preventDefault();
		
			// Restore the cube back to it's original once the mouse is no longer over it
			if ( selectedObject ) {

				if (waitOver)
					selectedObject.material.color = allColors[selectedObject.number];
				else
					selectedObject.material.color = selectedObject.original;

				selectedObject = null;


				for (var i = 0; i < linesInScene.length; i++)
					scene.remove( linesInScene[i] );
				linesInScene = [];
			}
		
			var intersects = getIntersects( event.layerX, event.layerY );
		
			// If the mouse is intersecting with an object, change it's color
			if ( intersects.length > 0 ) 
			{
				var res = intersects.filter( function ( res ) 
				{
					return res && res.object;
				} )[ 0 ];
        
                if ( res && res.object ) {
                    selectedObject = res.object;
                    res.object.material.color = HIGHLIGHT_COLOR;


                    if(selectedObject.number > 783){
                        //console.log(selectedObject.number);

                        if(!model.getLayer('', whichLayer(selectedObject.number)).name.includes("pool"))
	                    	for(let line = 0; line < selectedObject.lines.length; line++) {
	                    	    drawLine(selectedObject.lines[line].from, selectedObject.lines[line].to, allColors[selectedObject.number].lineColors[line]);
	                    	}
	                    else
	                    	for(let line = 0; line < selectedObject.lines.length; line++) {
	                    	    drawLine(selectedObject.lines[line].from, selectedObject.lines[line].to);
	                    	}
                    }
                }
				
			}
		}
		
		function getIntersects( x, y )
		{
		
			x =  ( x / window.innerWidth  ) * 2 - 1;
			y = -( y / window.innerHeight ) * 2 + 1;
			mouse.set( x, y, 0.5 );
			raycaster.setFromCamera( mouse, camera );
		
			return raycaster.intersectObject( group, true );
		}
		
		function animate() 
		{
		
			requestAnimationFrame( animate );
			render();
		
		}



		function layerVolume(l)
		{
		    let d;

		    let outputShape = model.layers[l].inboundNodes[0].outputShapes[0];

		    if (outputShape.length > 2)
            	d = {x: outputShape[1], y: outputShape[2], z: outputShape[3]};
            else
            	d = {x: outputShape[1]};

            return d;
		}

		function animateLines(i)
		{
            // let volume = [784, 4240, 5104, 5616, 5744, 5794];
            let volume = layerSum.slice(0);
		    let layer = whichLayer(i);
		    let v = layerVolume(layer);

			// for(let line = 0; line < cubeArray[i].lines.length; line++)
			// {
		    if(v && layer !=2)
			{
            	for(let depth = 0; depth < v.z; depth++)
            	{
            		for(let line = 0; line < cubeArray[i].lines.length; line++)
					{
                		drawLine(cubeArray[i + depth * (v.x * v.y - 1)].lines[line].from, cubeArray[i + depth * (v.x * v.y - 1)].lines[line].to);
                	}
                	cubeArray[i + depth * (v.x * v.y - 1)].material.color = allColors[i + depth * (v.x * v.y - 1)];
            	}
            }
		    else
		    {
		    	for(let line = 0; line < cubeArray[i].lines.length; line++)
				{
                	drawLine(cubeArray[i].lines[line].from, cubeArray[i].lines[line].to);
                }
                cubeArray[i].material.color = allColors[i];
		    }

            // }
            if(layer < 4 && layer != 2) {
                if((i - volume[layer] < v.x * v.y))
				{
				    cubeToAnimate++;
				}
                else
                	cubeToAnimate = volume[layer + 1];
            }
            else
                cubeToAnimate++;

		}

		function removeLines()
		{
			for (let k = 0; k < linesInScene.length; k++)
				scene.remove( linesInScene[k] );
			linesInScene = [];
		}
		
		function render() {

			// Outer if statement is to check whether it's in play or pause mode
			// Inner if statement is to rotate and pan camera around layers
			if ( isPlaying ) {
				// if ( theta < 90 ) {
		
				// 	camera.position.x = RADIUS * Math.sin( THREE.Math.degToRad( theta ) );
				// 	camera.position.z = RADIUS * Math.cos( THREE.Math.degToRad( theta ) );
				// 	theta += ROTATIONSPEED;
				// }
				// else if ( camera.position.z < PANDISTANCE ) {
		
				//  	camera.position.z -= PANSPEED;
				//  	scene.position.z  += PANSPEED;

				// }
                removeLines();
				// convAnimate();
				if(cubeToAnimate < cubeArray.length) {
                    animateLines(cubeToAnimate);
                    // cubeArray[cubeToAnimate].material.color = allColors[cubeToAnimate];
                    
                }
			}

			// restart
			if( plzRestart )
			{
				currentNode = 0;
				for (let i = 0; i < IMAGE_SIZE; i++)
					cubeArray[i].material.color = allColors[i];
				for(let i = IMAGE_SIZE; i < cubeArray.length; i++)
					cubeArray[i].material.color = new THREE.Color ( 0.3, 0.3, 0.3 );

				plzRestart = false;
			}

			if( isFinished )
			{
				for (let i = 0; i < cubeArray.length; i++)
				{
					cubeArray[i].material.color = allColors[i];
				}
				isFinished = false;
			}
		
			controls.update();
			renderer.render( scene, camera );
		}
		
		// animate computation
		function play() 
		{
			isPlaying = true;
			plzRestart = false;
			isFinished = false;
		}
		
		// pause animation
		function pause() 
		{
			isPlaying = false;
			plzRestart = false;
			isFinished = false;
		}
		
		// gray out output color
		function restart() {
      
      		cubeToAnimate = 784;
			isPlaying = false;
      
			theta = 0;
			// scene.position.set( 0, 0, 0 );
			// camera.position.set( 0, 0, RADIUS );
			// camera.lookAt( scene.position );
			plzRestart = true;
			isFinished = false;
		}

		// show all output
		function finish() 
		{
			isFinished = true;
			isPlaying = false;
			plzRestart = false;
		}

		// visualize next input
		function next() {
			isPlaying = false;
			plzRestart = false;
			isFinished = false;
			imgNum++;

			let input = data.datasetImages.slice(IMAGE_SIZE*imgNum, IMAGE_SIZE*(imgNum+1));
			IMG = oneDToMany(input, 1, 28, 28);

			colorCoat();

			for (let i = 0; i < cubeArray.length; i++)
			{
				cubeArray[i].material.color = allColors[i];
			}
		}

		window.play = play;
		window.pause = pause;
		window.restart = restart;
		window.finish = finish;
		window.next = next;
        
	</script>
	<div id="info">
		Super Awesome Convolutional Neural Network Visualizer<br/>
		By: Jonathon Rice, Richard DiBacco, Soliman Alnaizy</br>
		<button onclick="play();">Play</button>
		<button onclick="pause();">Pause</button>
		<button onclick="restart();">Restart</button>
		<button onclick="finish();">Finish</button>
		<button onclick="next();">Next</button>

	</div>
	
	<div id="roadmap">
		<br/>
		&nbsp;Road Map<br/>
		&nbsp;- <del>Color connections</del>, visibility&nbsp;</br>
		&nbsp;- Drag and drop layers together&nbsp;</br>
		&nbsp;- Import/Export models</br>
		&nbsp;- More datasets</br>
		&nbsp;- Visualization tools</br>
		&nbsp;- Large networks, new layers</br>
		&nbsp;- Log and rank models</br>
		&nbsp;- Import and connect datasets</br>
		&nbsp;- <i>Aesthetics</i></br>
		<br/>
	</div>
	</body>
</html>