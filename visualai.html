<!-- Jonathon Rice, Richard DiBacco, Soliman Alnaizy -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Neural Network Builder</title>
		<link rel="stylesheet" type="text/css" href="index.css">
	</head>
	<body>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"></script>
	<script src="lib/main.js"></script>
	<script type= "module" src="lib/model.js"></script>
	<script src="lib/Layer.js"></script>
	<script src="lib/Network.js"></script>
	<!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.0"> </script> -->
	<script>
		// GLOBAL VARIABLES
		var container; 		                                  // Will be used to add the .js script to the browser
		var camera, raycaster, renderer, scene;             // Three.js essentials
		var controls;                                       // For orbital controls
		var isPlaying = false, isDrawing = false;           // For the play/pause button
		var mouse = new THREE.Vector3();                    // For the raycaster
		var selectedObject = null, group;                   // For the raycaster
		var panDistance = 200;										          // Determines how face the camera pans

		// CONSTANTS
		var RADIUS = 300, THETA = 0;                        // Camera rotation and movement
		var HIGHLIGHT_COLOR = new THREE.Color ( 0xFF0000 ); // Object highlight for raycaster
		var PANSPEED = 1, ROTATIONSPEED = 1, DRAWLINESPEED = 1, LAYER_DELAY;

		// The first function that loads
		window.onload = function() {
			init();
			animate();
		}

		// Draws a line that connects the point p1 to point p2
		function draw(p1, p2) {
			var mat = new THREE.LineBasicMaterial({color:0x888888});
			var geo = new THREE.Geometry();
			geo.vertices.push( new THREE.Vertex(p1) );
			geo.vertices.push( new THREE.Vertex(p2) );
			var line = new THREE.Line(geo);
			scene.add(line);
			return line
		}

		function createLayer( mnistNetwork ) {
			for (var layer; layer < mnistNetwork.length; layer++ ) {	
				v3loop( mnistNetwork[layer].volume, ( i, j, k ) => {
					scene.add( mnistNetwork[layer].nodes[k][j][i] );
				});
			}
		}

		// Make a request for the MNIST sprited image.
		const imgRequest = new Promise((resolve, reject) =>
		{
			img.crossOrigin = '';
			img.onload = () =>
			{
				img.width = img.naturalWidth;
				img.height = img.naturalHeight;

				const datasetBytesBuffer = new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE * 4);
				const chunkSize = 5000;
				canvas.width = img.width;
				canvas.height = chunkSize;

				for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++)
				{
					const datasetBytesView = new Float32Array(datasetBytesBuffer, i * IMAGE_SIZE * chunkSize * 4, IMAGE_SIZE * chunkSize);
					ctx.drawImage(img, 0, i * chunkSize, img.width, chunkSize, 0, 0, img.width, chunkSize);
					const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

					for (let j = 0; j < imageData.data.length / 4; j++)
					{
						// All channels hold an equal value since the image is grayscale, so
						// just read the red channel.
						datasetBytesView[j] = imageData.data[j * 4] / 255;
					}
				}
				this.datasetImages = new Float32Array(datasetBytesBuffer);
				const img1 = this.datasetImages.slice(IMAGE_SIZE * 1, IMAGE_SIZE * 2);

				var geometry = new THREE.BoxGeometry( 10, 10, 10 );
				var c, k=0, R = 0, G = 0, B = 0;
				console.log(img1);
				for(let i= -14; i < 14; i++)
				{
					for(let j= -14; j < 14; j++, k++)
					{
						if(img1[k] <= .5)
						{
							R = 0;
							B = 1 - 2*img1[k];
							G = 2*img1[k];
						}
						else
						{
							B = 0;
							R = 2*img1[k] - 1;
							G = 2 - 2*img1[k];
						}
						var colors = new THREE.Color( R, G, B );
						var material = new THREE.MeshBasicMaterial( { color: colors } );
						var cube = new THREE.Mesh( geometry, material );

						cube.position.x += 12*i;
						cube.position.y += 12*j;
						cube.original = colors;

						scene.add( cube );
						group.add( cube );
					}
				}
			};

				img.src = MNIST_IMAGES_SPRITE_PATH;
		});

		// Initializes all the necessary variables for a basic THREE.js application
		function init() {

			container = document.createElement( 'div' );
			document.body.appendChild( container );

			// Renderer stuff
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			container.appendChild( renderer.domElement );

			// Setting the scene
			scene = new THREE.Scene();

			// Camera stuff
			var aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
			scene.add( camera );

			// Light stuff
			var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 1.0 );
			scene.add( ambientLight );

			// A Raycaster can tell what object is the mouse hovering over
			raycaster = new THREE.Raycaster();
			group = new THREE.Group();
			scene.add( group );

			// Add the layers to the scene
			var geometry = new THREE.BoxGeometry( 10, 10, 10);
			for(let t=0; t<4; t++)
			{
				for(let i=-4; i < 4; i++)
				{
					for(let j=-4; j < 4; j++)
					{
							var c = Math.random()
							if(c <= .5)
							{
								R = 0;
								B = 1 - 2*c;
								G = 2*c;
							}
							else
							{
								B = 0;
								R = 2*c - 1;
								G = 2 - 2*c;
							}

							var colors = new THREE.Color( R, G, B );
							var material = new THREE.MeshBasicMaterial( { color: colors } );
							var cube = new THREE.Mesh( geometry, material );

							cube.position.x += 12*i;
							cube.position.y += 12*j;
							cube.position.z += t*-50;
							cube.original = colors;

							scene.add( cube );
							group.add( cube );
					}
				}
			}

			controls = new THREE.OrbitControls( camera, renderer.domElement );

			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.screenSpacePanning = false;
			controls.maxPolarAngle = Math.PI / 2;

			// Makes the animation adapt to the size of the window
			window.addEventListener( "resize", resize, false );

			// This is what highlights the cubes when the mouse is over an object
			window.addEventListener( "mousemove", highlightObject, false );
		}

		// The program adapts to the size of the browser window
		function resize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		// For the raycaster
		function highlightObject( event ) {

			event.preventDefault();

			// Restore the cube back to it's original once the mouse is no longer over it
			if ( selectedObject ) {
				selectedObject.material.color.set( selectedObject.original );
				selectedObject = null;
			}

			var intersects = getIntersects( event.layerX, event.layerY );

			// If the mouse is intersecting with an object, change it's color
			if ( intersects.length > 0 ) {
				var res = intersects.filter( function ( res ) {
					return res && res.object;
				} )[ 0 ];

				if ( res && res.object ) {
					selectedObject = res.object;
					selectedObject.material.color.set( HIGHLIGHT_COLOR );
				}
			}
		}

		function getIntersects( x, y ) {

			x =  ( x / window.innerWidth  ) * 2 - 1;
			y = -( y / window.innerHeight ) * 2 + 1;
			mouse.set( x, y, 0.5 );
			raycaster.setFromCamera( mouse, camera );

			return raycaster.intersectObject( group, true );
		}

		function animate() {

			requestAnimationFrame( animate );
			render();

		}

		function render() {

			// Outer if statement is to check whether it's in play or pause mode
			// Inner if statement is to rotate and pan camera around layers
			if ( isPlaying ) {
				if ( THETA < 90 ) {

					camera.position.x = RADIUS * Math.sin( THREE.Math.degToRad( THETA ) );
					camera.position.z = RADIUS * Math.cos( THREE.Math.degToRad( THETA ) );
					camera.lookAt( scene.position );
					THETA += ROTATIONSPEED;

				} else if ( scene.position.z < panDistance ) {
					camera.position.z -= PANSPEED;
					scene.position.z  += PANSPEED;
				}
			}

			controls.update();
			renderer.render( scene, camera );
		}

		function play() {
			isPlaying = true;
		}

		function pause() {
			isPlaying = false;
		}

		function restart() {
			isPlaying = false;
			THETA = 0;
			scene.position.set( 0, 0, 0 );
			camera.position.set( 0, 0, RADIUS );
			camera.lookAt( scene.position );
		}

	</script>
	<div id="info">
		Super Awesome Convolutional Neural Network Visualizer<br/>
		By: Jonathon Rice, Richard DiBacco, Soliman Alnaizy</br>
		<button onclick="play();">Play</button>
		<button onclick="pause();">Pause</button>
		<button onclick="restart();">Restart</button>

	</div>
	</body>
</html>

<!-- 
Not my code but it was getting in the way so I moved it down here. - Soliman

				// for(let t=0; t<4; t++)
				// {
				//  for(let i=-14; i < 14; i++)
				//  {
				//    for(let j=-14; j < 14; j++)
				//    {
				//      c = Math.random()
				//      if(c <= .5)
				//      {
				//        R = 0;
				//        B = 1 - 2*c;
				//        G = 2*c;
				//      }
				//      else
				//      {
				//        B = 0;
				//        R = 2*c - 1;
				//        G = 2 - 2*c;
				//      }

				//      var colors = new THREE.Color( R, G, B );
				//      var material = new THREE.MeshBasicMaterial( { color: colors } );
				//      var cube = new THREE.Mesh( geometry, material );

				//      cube.position.x += 1.2*i;
				//      cube.position.y += 1.2*j;
				//      cube.position.z += -12 + t*-2;
				//      scene.add( cube );
				//    }
				//  }
				// }

				// for(var t=0; t<4; t++)
				// {
				//  for(var i=-7; i < 7; i++)
				//  {
				//    for(var j=-7; j < 7; j++)
				//    {
				//      c = Math.random()
				//      if(c <= .5)
				//      {
				//        R = 0;
				//        B = 1 - 2*c;
				//        G = 2*c;
				//      }
				//      else
				//      {
				//        B = 0;
				//        R = 2*c - 1;
				//        G = 2 - 2*c;
				//      }

				//      var colors = new THREE.Color( R, G, B );
				//      var material = new THREE.MeshBasicMaterial( { color: colors } );
				//      var cube = new THREE.Mesh( geometry, material );

				//      cube.position.x += 1.2*i;
				//      cube.position.y += 1.2*j;
				//      cube.position.z += -24 + t*-2;

				//      scene.add( cube );
				//    }
				//  }
				// }

				// for(var j=-5; j < 5; j++)
				// {
				//  c = Math.random()
				//  if(c <= .5)
				//  if(c <= .5)
				//  {
				//    R = 0;
				//    B = 1 - 2*c;
				//    G = 2*c;
				//  }
				//  else
				//  {
				//    B = 0;
				//    R = 2*c - 1;
				//    G = 2 - 2*c;
				//  }


				//  var colors = new THREE.Color( R, G, B );
				//  var material = new THREE.MeshBasicMaterial( { color: colors } );
				//  var cube = new THREE.Mesh( geometry, material );

				//  cube.position.x += 1.2*j;
				//  // cube.position.y += 1.2*j
				//  cube.position.z += -36;

				//  scene.add( cube );
				// }
				 -->

<!-- 				 
				camera.position.x = 40;

				let render = function ()
				{
					// requestAnimationFrame( render );
					// cube.setColor(1*Math.random(), 1*Math.random(), 1*Math.random());
					renderer.render( scene, camera );
				};

				let cameraControl = new THREE.OrbitControls( camera );
				cameraControl.addEventListener( 'change', render );
				render();
				resolve();
 -->

 <!-- 
												// var colors = new THREE.Color( 1*img1[k], 1*img1[k], 1*img1[k] );
						// draw(new THREE.Vector3(cube.position.x,cube.position.y,cube.position.z),new THREE.Vector3(cube.position.x,cube.position.y,(cube.position.z-12)); -->

<!-- 						
			// var spotLight    = new THREE.SpotLight ( 0xffffff, 1, 0, Math.PI / 2 )
			// spotLight.position.set( 0, 300, 500 );
			// spotLight.target.position.set( 0, 0, 0 );
			// spotLight.castShadow = true;

			// ~~ GROUND: I'll try to add shadows to make it look super legit. This is on pause for now ~~
			// var geometry = new THREE.PlaneBufferGeometry( 100, 100 );
			// var planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
			// var ground = new THREE.Mesh( geometry, planeMaterial );
			// ground.position.set( 0, -150, 0 );
			// ground.scale.set( 100, 100, 100 );
			// ground.rotation.x = - Math.PI / 2;
			// ground.castShadow = false;
			// ground.receiveShadow = true;
			// ground.material.side = THREE.DoubleSide;

			// Create and add objects to the scene
			// scene.add( spotLight );
			// scene.add( ground );
 -->